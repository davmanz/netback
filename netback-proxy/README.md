# Netback â€” Proxy (FastAPI BFF)\n\nServicio **FastAPI** que actÃºa como **BFF / API Gateway** entre el **Frontend** y el **Backend Django**.\nCentraliza **autenticaciÃ³n**, **CORS**, y simplifica el consumo de la API REST del backend.\n\n---\n\n## ğŸ§­ Â¿QuÃ© hace?\n- Expone un endpoint de **login** y reenvÃ­a solicitudes al backend.\n- **Valida JWT** recibido del frontend (cabecera `Authorization: Bearer &lt;token&gt;`).\n- Protege rutas mediante dependencias (`auth_required`, `admin_required`) que consultan al backend `GET /api/users/me/`.\n- Unifica CORS para el frontend.\n\nArquitectura (simplificada):\n```\nBrowser â†’ Nginx (frontend) â†’ /api/* â†’ FastAPI Proxy â†’ Django REST API â†’ DB/Redis/Celery\n```\n\n---\n\n## ğŸ—ï¸ Stack\n- **FastAPI** + **Uvicorn**\n- **httpx** / **requests** para llamadas al backend\n- **python-dotenv** para configuraciÃ³n por `.env`\n- **Docker** para despliegue\n\n> Ver `requirements.txt` para las versiones exactas.\n\n---\n\n## ğŸ”Œ Endpoints principales\n- **Auth**\n  - `POST /auth/login/` â†’ Delegado al backend `POST /api/token/` (retorna `access` y `refresh`).\n\n- **Rutas protegidas**\n  - Los mÃ³dulos `users`, `devices`, `backups`, `vault`, `locations`, `utils` exponen rutas que **validan el JWT** con `auth_required` y, si corresponde, con `admin_required`.\n  - La validaciÃ³n consulta `GET {DJANGO_API}/users/me/` para comprobar el rol.\n\n- **Healthcheck**\n  - Sugerido: `GET /health/` respondiendo `{status: "ok"}`. (Si aÃºn no existe, implementarlo en `app/routes/utils.py`).\n\n---\n\n## âš™ï¸ ConfiguraciÃ³n por entorno\nSe cargan desde `.env` (ver `app/config.py`).\n\n```\n# URL del Backend Django\nDJANGO_API_PROTOCOL=http\nDJANGO_API_URL=netback-backend\nDJANGO_API_PORT=8000\n\n# DirecciÃ³n donde escucha el Proxy\nFASTAPI_PROXY_URL=0.0.0.0\nFASTAPI_PROXY_PORT=8080\n\n# CORS\nALLOW_ORIGINS=http://localhost,http://localhost:80\nALLOW_CREDENTIALS=true\nALLOW_METHODS=GET,POST,PUT,PATCH,DELETE,OPTIONS\nALLOW_HEADERS=Content-Type,Authorization\n\n# DEBUG del proxy (opcional)\nFASTAPI_PROXY_DEBUG=false\n```\n\n> En cÃ³digo, se construye `full_django_api_url = {protocol}://{url}:{port}/api`.\n\n---\n\n## â–¶ï¸ CÃ³mo ejecutar\n### Con Docker (recomendado)\nSe orquesta desde la raÃ­z con `docker-compose.yml` (servicio `proxy`).\n\n```bash\ndocker compose up -d --build proxy\n```\n\n### Local (desarrollo)\n```bash\ncd netback-proxy\npython -m venv .venv && source .venv/bin/activate\npip install -r requirements.txt\n# Cargar variables\nexport $(cat ../netback-env/.env | xargs)\nuvicorn main:app --host ${FASTAPI_PROXY_URL:-0.0.0.0} --port ${FASTAPI_PROXY_PORT:-8080} --reload\n```\n\n---\n\n## ğŸ” Seguridad\n- El proxy **no emite** JWT propio: delega en Django (`/api/token/`).\n- Toda ruta protegida debe incluir `Authorization: Bearer &lt;access&gt;`.\n- `admin_required` verifica `role == \"admin\"` vÃ­a `GET /api/users/me/` del backend.\n- MantÃ©n `FASTAPI_PROXY_DEBUG=false` en producciÃ³n.\n\n---\n\n## ğŸ§ª Ejemplos\n**Login**\n```bash\ncurl -X POST http://localhost:8080/auth/login/ \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"username\":\"admin\",\"password\":\"adminpassword\"}'\n```\n\n**Llamada protegida (ejemplo)**\n```bash\ncurl http://localhost:8080/users/me/ \\\n  -H 'Authorization: Bearer &lt;ACCESS_TOKEN&gt;'\n```\n\n---\n\n## ğŸ“‚ Estructura\n```\nnetback-proxy/\nâ”œâ”€ app/\nâ”‚  â”œâ”€ config.py          # Settings desde .env\nâ”‚  â”œâ”€ dependencies.py    # auth_required / admin_required\nâ”‚  â””â”€ routes/\nâ”‚     â”œâ”€ auth.py         # /auth/login/\nâ”‚     â”œâ”€ users.py        # rutas de usuarios (protegidas)\nâ”‚     â”œâ”€ devices.py      # rutas de dispositivos (protegidas)\nâ”‚     â”œâ”€ backups.py      # rutas de backups (protegidas)\nâ”‚     â”œâ”€ locations.py    # paÃ­ses/sitios/Ã¡reas (protegidas)\nâ”‚     â”œâ”€ vault.py        # gestiÃ³n de credenciales (protegidas)\nâ”‚     â””â”€ utils.py        # utilidades (p.ej. /health/)\nâ”œâ”€ main.py               # InicializaciÃ³n FastAPI y montaje de routers\nâ”œâ”€ requirements.txt\nâ””â”€ Dockerfile\n```\n\n---\n\n## ğŸ“ Notas relevantes\n- **CORS**: definido solo aquÃ­ para simplificar el frontend.\n- **Healthcheck**: expÃ³n `/health/` y Ãºsa en `docker-compose.yml` (servicio `proxy`).\n- **Errores**: `dependencies.py` devuelve `401` si no hay token/expirado, `403` si falta rol.\n\n---\n\n## ğŸ§ª Pruebas rÃ¡pidas (Smoke tests)\n\nHay un set de pruebas ligeras para validar de punta a punta el flujo Frontendâ†’Proxyâ†’Backend con cookies/CSRF y propagaciÃ³n correcta de cÃ³digos HTTP.\n\n- UbicaciÃ³n: `netback-proxy/tools/smoke/`\n- Tests disponibles:\n  - `test_vaultcredentials.py` â€” CRUD de credenciales de vault\n  - `test_users.py` â€” CRUD de usuarios (usa PATCH para updates parciales)\n  - `test_devices.py` â€” CRUD de dispositivos (crea una credencial temporal)\n  - `test_locations.py` â€” Countries, Sites y Areas: create/list/patch/delete\n  - `test_classification_rules.py` â€” CRUD de classification-rules (asocia vault)\n  - `test_zabbix.py` â€” Status y flujo desde Zabbix (sin servidor Zabbix real)\n  - `run_all.py` â€” ejecuta todos los tests en orden\n\nRequisitos previos:\n- Servicios levantados vÃ­a Docker Compose (backend y proxy).\n- Usuario admin disponible (por defecto `admin/admin` en desarrollo).\n\nVariables de entorno (opcionales):\n- `SMOKE_BASE_URL` (default: `http://localhost:8080`)\n- `SMOKE_USER` y `SMOKE_PASS` (default: `admin` / `admin`)\n- `SMOKE_TIMEOUT` en segundos (default: `15`)\n\nCÃ³mo ejecutar todos los tests usando Docker Compose:\n\n```bash\ndocker compose exec -e SMOKE_USER=admin -e SMOKE_PASS=admin proxy \\\n  python -m tools.smoke.run_all\n```\n\nCÃ³mo ejecutar un test especÃ­fico:\n\n```bash\n# Vault credentials\ndocker compose exec proxy python -m tools.smoke.test_vaultcredentials\n\n# Users\ndocker compose exec proxy python -m tools.smoke.test_users\n\n# Devices\ndocker compose exec proxy python -m tools.smoke.test_devices\n\n# Locations (countries/sites/areas)\ndocker compose exec proxy python -m tools.smoke.test_locations\n\n# Classification rules\ndocker compose exec proxy python -m tools.smoke.test_classification_rules\n\n# Zabbix (acepta error/timeout controlado si no hay Zabbix real)\ndocker compose exec proxy python -m tools.smoke.test_zabbix\n```\n\nResultados esperados (resumen):\n- Create: 201\n- List: 200\n- Update/Patch: 200 o 202\n- Delete: 204\n- Zabbix:\n  - `GET /zabbix/status/`: 200 con JSON de estado.\n  - `POST /networkdevice/bulk/from-zabbix/` sin `ruleSetId`: 400 con detalle.\n  - Con `ruleSetId` vÃ¡lido: JSON de backend o `504` â€œZabbix upstream timeoutâ€ (esperado si no hay Zabbix).\n\nTroubleshooting:\n- 403 CSRF token invÃ¡lido: asegÃºrate de que el proxy reenvÃ­a cookies y cabecera `X-CSRF-Token` (los tests ya lo hacen). Revisa Path y SameSite de cookies.\n- 401 no autorizado: credenciales errÃ³neas o token expirado. Vuelve a hacer login.\n- 5xx: inspecciona logs de proxy y backend (`docker compose logs proxy backend`).\n- Deletes de locations: se realizan por el catchâ€‘all `/api/...` si no hay rutas DELETE explÃ­citas en el proxy.\n\nSugerencias de mantenimiento de tests:\n- Usa `ProxySession` de `tools/smoke/common.py` para manejar login, cookies y CSRF automÃ¡ticamente.\n- Para operaciones lentas, pasa `timeout` al construir `ProxySession` o exporta `SMOKE_TIMEOUT`.\n- Limpia siempre los recursos creados (los tests actuales ya eliminan lo que crean).\n\n---\n\n## Licencia\nProyecto interno Netback. Uso restringido.\n