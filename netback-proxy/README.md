# Netback — Proxy (FastAPI BFF)\n\nServicio **FastAPI** que actúa como **BFF / API Gateway** entre el **Frontend** y el **Backend Django**.\nCentraliza **autenticación**, **CORS**, y simplifica el consumo de la API REST del backend.\n\n---\n\n## 🧭 ¿Qué hace?\n- Expone un endpoint de **login** y reenvía solicitudes al backend.\n- **Valida JWT** recibido del frontend (cabecera `Authorization: Bearer &lt;token&gt;`).\n- Protege rutas mediante dependencias (`auth_required`, `admin_required`) que consultan al backend `GET /api/users/me/`.\n- Unifica CORS para el frontend.\n\nArquitectura (simplificada):\n```\nBrowser → Nginx (frontend) → /api/* → FastAPI Proxy → Django REST API → DB/Redis/Celery\n```\n\n---\n\n## 🏗️ Stack\n- **FastAPI** + **Uvicorn**\n- **httpx** / **requests** para llamadas al backend\n- **python-dotenv** para configuración por `.env`\n- **Docker** para despliegue\n\n> Ver `requirements.txt` para las versiones exactas.\n\n---\n\n## 🔌 Endpoints principales\n- **Auth**\n  - `POST /auth/login/` → Delegado al backend `POST /api/token/` (retorna `access` y `refresh`).\n\n- **Rutas protegidas**\n  - Los módulos `users`, `devices`, `backups`, `vault`, `locations`, `utils` exponen rutas que **validan el JWT** con `auth_required` y, si corresponde, con `admin_required`.\n  - La validación consulta `GET {DJANGO_API}/users/me/` para comprobar el rol.\n\n- **Healthcheck**\n  - Sugerido: `GET /health/` respondiendo `{status: "ok"}`. (Si aún no existe, implementarlo en `app/routes/utils.py`).\n\n---\n\n## ⚙️ Configuración por entorno\nSe cargan desde `.env` (ver `app/config.py`).\n\n```\n# URL del Backend Django\nDJANGO_API_PROTOCOL=http\nDJANGO_API_URL=netback-backend\nDJANGO_API_PORT=8000\n\n# Dirección donde escucha el Proxy\nFASTAPI_PROXY_URL=0.0.0.0\nFASTAPI_PROXY_PORT=8080\n\n# CORS\nALLOW_ORIGINS=http://localhost,http://localhost:80\nALLOW_CREDENTIALS=true\nALLOW_METHODS=GET,POST,PUT,PATCH,DELETE,OPTIONS\nALLOW_HEADERS=Content-Type,Authorization\n\n# DEBUG del proxy (opcional)\nFASTAPI_PROXY_DEBUG=false\n```\n\n> En código, se construye `full_django_api_url = {protocol}://{url}:{port}/api`.\n\n---\n\n## ▶️ Cómo ejecutar\n### Con Docker (recomendado)\nSe orquesta desde la raíz con `docker-compose.yml` (servicio `proxy`).\n\n```bash\ndocker compose up -d --build proxy\n```\n\n### Local (desarrollo)\n```bash\ncd netback-proxy\npython -m venv .venv && source .venv/bin/activate\npip install -r requirements.txt\n# Cargar variables\nexport $(cat ../netback-env/.env | xargs)\nuvicorn main:app --host ${FASTAPI_PROXY_URL:-0.0.0.0} --port ${FASTAPI_PROXY_PORT:-8080} --reload\n```\n\n---\n\n## 🔐 Seguridad\n- El proxy **no emite** JWT propio: delega en Django (`/api/token/`).\n- Toda ruta protegida debe incluir `Authorization: Bearer &lt;access&gt;`.\n- `admin_required` verifica `role == \"admin\"` vía `GET /api/users/me/` del backend.\n- Mantén `FASTAPI_PROXY_DEBUG=false` en producción.\n\n---\n\n## 🧪 Ejemplos\n**Login**\n```bash\ncurl -X POST http://localhost:8080/auth/login/ \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"username\":\"admin\",\"password\":\"adminpassword\"}'\n```\n\n**Llamada protegida (ejemplo)**\n```bash\ncurl http://localhost:8080/users/me/ \\\n  -H 'Authorization: Bearer &lt;ACCESS_TOKEN&gt;'\n```\n\n---\n\n## 📂 Estructura\n```\nnetback-proxy/\n├─ app/\n│  ├─ config.py          # Settings desde .env\n│  ├─ dependencies.py    # auth_required / admin_required\n│  └─ routes/\n│     ├─ auth.py         # /auth/login/\n│     ├─ users.py        # rutas de usuarios (protegidas)\n│     ├─ devices.py      # rutas de dispositivos (protegidas)\n│     ├─ backups.py      # rutas de backups (protegidas)\n│     ├─ locations.py    # países/sitios/áreas (protegidas)\n│     ├─ vault.py        # gestión de credenciales (protegidas)\n│     └─ utils.py        # utilidades (p.ej. /health/)\n├─ main.py               # Inicialización FastAPI y montaje de routers\n├─ requirements.txt\n└─ Dockerfile\n```\n\n---\n\n## 📝 Notas relevantes\n- **CORS**: definido solo aquí para simplificar el frontend.\n- **Healthcheck**: expón `/health/` y úsa en `docker-compose.yml` (servicio `proxy`).\n- **Errores**: `dependencies.py` devuelve `401` si no hay token/expirado, `403` si falta rol.\n\n---\n\n## 🧪 Pruebas rápidas (Smoke tests)\n\nHay un set de pruebas ligeras para validar de punta a punta el flujo Frontend→Proxy→Backend con cookies/CSRF y propagación correcta de códigos HTTP.\n\n- Ubicación: `netback-proxy/tools/smoke/`\n- Tests disponibles:\n  - `test_vaultcredentials.py` — CRUD de credenciales de vault\n  - `test_users.py` — CRUD de usuarios (usa PATCH para updates parciales)\n  - `test_devices.py` — CRUD de dispositivos (crea una credencial temporal)\n  - `test_locations.py` — Countries, Sites y Areas: create/list/patch/delete\n  - `test_classification_rules.py` — CRUD de classification-rules (asocia vault)\n  - `test_zabbix.py` — Status y flujo desde Zabbix (sin servidor Zabbix real)\n  - `run_all.py` — ejecuta todos los tests en orden\n\nRequisitos previos:\n- Servicios levantados vía Docker Compose (backend y proxy).\n- Usuario admin disponible (por defecto `admin/admin` en desarrollo).\n\nVariables de entorno (opcionales):\n- `SMOKE_BASE_URL` (default: `http://localhost:8080`)\n- `SMOKE_USER` y `SMOKE_PASS` (default: `admin` / `admin`)\n- `SMOKE_TIMEOUT` en segundos (default: `15`)\n\nCómo ejecutar todos los tests usando Docker Compose:\n\n```bash\ndocker compose exec -e SMOKE_USER=admin -e SMOKE_PASS=admin proxy \\\n  python -m tools.smoke.run_all\n```\n\nCómo ejecutar un test específico:\n\n```bash\n# Vault credentials\ndocker compose exec proxy python -m tools.smoke.test_vaultcredentials\n\n# Users\ndocker compose exec proxy python -m tools.smoke.test_users\n\n# Devices\ndocker compose exec proxy python -m tools.smoke.test_devices\n\n# Locations (countries/sites/areas)\ndocker compose exec proxy python -m tools.smoke.test_locations\n\n# Classification rules\ndocker compose exec proxy python -m tools.smoke.test_classification_rules\n\n# Zabbix (acepta error/timeout controlado si no hay Zabbix real)\ndocker compose exec proxy python -m tools.smoke.test_zabbix\n```\n\nResultados esperados (resumen):\n- Create: 201\n- List: 200\n- Update/Patch: 200 o 202\n- Delete: 204\n- Zabbix:\n  - `GET /zabbix/status/`: 200 con JSON de estado.\n  - `POST /networkdevice/bulk/from-zabbix/` sin `ruleSetId`: 400 con detalle.\n  - Con `ruleSetId` válido: JSON de backend o `504` “Zabbix upstream timeout” (esperado si no hay Zabbix).\n\nTroubleshooting:\n- 403 CSRF token inválido: asegúrate de que el proxy reenvía cookies y cabecera `X-CSRF-Token` (los tests ya lo hacen). Revisa Path y SameSite de cookies.\n- 401 no autorizado: credenciales erróneas o token expirado. Vuelve a hacer login.\n- 5xx: inspecciona logs de proxy y backend (`docker compose logs proxy backend`).\n- Deletes de locations: se realizan por el catch‑all `/api/...` si no hay rutas DELETE explícitas en el proxy.\n\nSugerencias de mantenimiento de tests:\n- Usa `ProxySession` de `tools/smoke/common.py` para manejar login, cookies y CSRF automáticamente.\n- Para operaciones lentas, pasa `timeout` al construir `ProxySession` o exporta `SMOKE_TIMEOUT`.\n- Limpia siempre los recursos creados (los tests actuales ya eliminan lo que crean).\n\n---\n\n## Licencia\nProyecto interno Netback. Uso restringido.\n